import java.util.List;
import java.util.ArrayList;

public class Word {
  private String mName;
  // name of the word
  private static List<Word> instances = new ArrayList<Word>();
  // List of words generated by the constructor, a name is entered in the argument for the constructor, which uses instances.add(this) to add to instances the lastest instantiation of the class, which produces an object.
  private List<Definition> mDefinitions;
  // list of definitions, this member variable is the storage space for the definitions that are added by the "addDefinitions" function to the empty arraylist available in the constructor. Also note, I think that <Definition> in this arrayList actually does call the Definition class so.
  private int mId;
  // the id of the word is stored here, which is also generated by the constructor, which grabs the current size of the instances (aka the words) array.

  public Word(String name) {
    mName = name;
    // the name entered in the frontend is used to store the attribute mName.
    instances.add(this);
    // instances refers to the class' List of words, of which we are adding the currently instantiated name of the word, since that's the only thing being passed through the constructor to generate an object.
    mDefinitions = new ArrayList<Definition>();
    // mDefinitions is a fresh arraylist that is available for the "addDefinitions" function to add to.
    mId = instances.size();
    // mId provides a single incrementing number to each word by asking for the current size of the arraylist that is holding the words that are added to the class.
  }

  public String getName() {
    return mName;
  }
  // using the best practices of encapsulation, the getName function offers the name attribute of the private object instantiated by the constructor.

  public static List<Word> all() {
    return instances;
  }
  // the all function returns our current total list of words stored as an attribute of the class Word.

  public void addDefinition(Definition definition) {
    mDefinitions.add(definition);
  }
  // the addDefinition function receives an argument, so you can call this function on a single instance of a word... I think the way I'm doing it now in the front end is calling up the word array and the definitions array side by side. To add definitions to the word object, we're passing Definition objects through to our Word class. Weee. 

  public List<Definition> getDefinitions() {
    return mDefinitions;
  }
  // this function returns the private arraylist of definitions stored in our class.

  public static void clear() {
    instances.clear();
  }
  // the clear function allows the user to clear out EVERY SINGLE definition and start their list from scratch. This function is currently not used in the frontend, but is available for use. I guess.

  public int getId() {
    return mId;
  }
  // the getId function returns the id, or which is the current size of the arraylist of words. The id is specifically used for RESTful routing, when you get the id of the word to route to a webpage that holds JUST that word and its associated attributes, if you choose.

  public static Word find(int id) {
    return instances.get(id-1);
  }
  // the find function is named a bit tricky... what this does is calls on the ENTIRE object list within the Word class, (or "Word.find(argument)") with the id (or when we call "find" in the frontend, the argument is typically "Integer.parseInt(request.params(":id"))"). What spits out of the find function is a particular object stored in the class, which is a word. So the whole thing is "Word word = Word.find(Integer.parseInt(request.params(":id")));" The return is a word within the instances arraylist, which is the id-1 because the .size() function in java begins counting the number of items in your list at 1, but the .get() function in java grabs the first item in an arraylist starting at 0.
}
